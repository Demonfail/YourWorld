<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprTraffic</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
scale = 0.65;//0.21;
//diff = (sprite_yoffset*1.5)/sprite_get_height(sprCarBody);
image_xscale = scale;//diff*scale;
image_yscale = scale;//diff*scale;

// Traffic flow test
alarm[0] = 30;
parked = false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Get the block we are currently on
var hasRoad = false;
var xx = floor(x/64);
var yy = ceil(y/64);
var zz = 4; // Defining this as it may later be used for varying heights
var cellValue = GetBlockIndex(xx, -yy, zz);
if (cellValue)
    {
    var block = MakeUnique(global.Map, xx, -yy, zz);
    var info  = oMap.block_info[block];
    var roadFlags = (info[BLK_FLAGS1] &gt;&gt; 22) &amp; $F;
    if (roadFlags)
        {
        xPos = x + lengthdir_x(64, direction);
        yPos = y + lengthdir_y(64, direction);
        inst = instance_nearest(xPos, yPos, objTrafficCar);
        if (point_distance(xPos, yPos, inst.x, inst.y) &gt; 32)
            {
            hasRoad = true;
            }
        }
    }
    
// Move from the current block in current direction, and set new direction from that block
if (hasRoad)
    {
    //debug("car has road");
    x += lengthdir_x(64, direction);
    y += lengthdir_y(64, direction);
    
    // Get the new block we are on, and change direction accordingly
    xx = floor(x/64);
    yy = ceil(y/64);
    cellValue = GetBlockIndex(xx, -yy, zz);
    if (cellValue)
        {
        block = MakeUnique(global.Map, xx, -yy, zz);
        info  = oMap.block_info[block];
        roadFlags = (info[BLK_FLAGS1] &gt;&gt; 22) &amp; $F;
        if (roadFlags)
            {
            // Get flags
            var north = (roadFlags &amp; 8) &gt; 0; // 1000 = 8
            var east  = (roadFlags &amp; 4) &gt; 0; // 0100 = 4
            var south = (roadFlags &amp; 2) &gt; 0; // 0010 = 2
            var west  = (roadFlags &amp; 1) &gt; 0; // 0001 = 1
            
            // Get a default direction
            for (n=0; n&lt;4; n++)
                {
                switch (n)
                    {
                    case (0): potentialDir = 270; break;
                    case (1): potentialDir = 0;   break;
                    case (2): potentialDir = 90;  break;
                    case (3): potentialDir = 180; break;
                    }
                
                // Cancel directions in case of collision
                xPos = x + lengthdir_x(64, potentialDir);
                yPos = y + lengthdir_y(64, potentialDir);
                inst = instance_nearest(xPos, yPos, objTrafficCar);
                if (point_distance(xPos, yPos, inst.x, inst.y) &lt; 32)
                &amp;&amp; (inst.parked == true)
                    {
                    switch (n)
                        {
                        case (0): north = false; break;
                        case (1): east  = false; break;
                        case (2): south = false; break;
                        case (3): west  = false; break;
                        }
                    }
                }
                
            // Get a default direction
            if (north) direction = 270;
            if (east)  direction = 0;
            if (south) direction = 90;
            if (west)  direction = 180;
                
            // Chose a random direction if possible
            if (north &amp;&amp; choose(0, 1)) direction = 270;
            if (east  &amp;&amp; choose(0, 1)) direction = 0;
            if (south &amp;&amp; choose(0, 1)) direction = 90;
            if (west  &amp;&amp; choose(0, 1)) direction = 180;
            }
        else
            {
            parked = true;
            }
        }
    }

alarm[0] = 10;
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
image_angle = direction+90;

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>25,107</point>
    <point>54,54</point>
  </PhysicsShapePoints>
</object>
