<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//*****************************************************************************
// 
// List system format:
//  string cellID (Example: "x12y5z2")
//  real   fixtureIndex (so we can reuse one of the right type)
//  real   phyInstID
//

// Define physics world
physics_world_create(1/16);
physics_world_gravity(0.0, 0.0);

// Get infomation that we need
gridWidth  = oMap.MapWidth;
gridHeight = oMap.MapHeight;
cellCenterX = 0;
cellCenterY = 0;
halfRegion = 2;

// Setup lists
instanceList = ds_list_create();
phyCache = ds_list_create();    // List of items from previous pass
phyActive = ds_list_create();   // List of currently active items
phyFree = ds_list_create();     // List of items that are free and ready for reuse

// Define shapes
PhysicsDefineBlock();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Free lists
ds_list_destroy(phyFree);
ds_list_destroy(phyActive);
ds_list_destroy(phyCache);

// Destroy instances
with (objFixture) instance_destroy();
with (objBody) instance_destroy();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Compile list of instances that require building collision
ds_list_clear(instanceList);
index = 0;
ds_list_add(instanceList, objBody);

// Sort physics enabled traffic into list
for (n=0; n&lt;instance_number(objTrafficCar); n++)
    {
    i = instance_find(objTrafficCar, n);
    if (!i.active)
        ds_list_add(instanceList, i);
    }
    
// Sort moving physics objects into list
for (n=0; n&lt;instance_number(parObject); n++)
    {
    i = instance_find(parObject, n);
    if (i.moving)
        ds_list_add(instanceList, i);
    }
    
// Sort moving physics object particles into list
for (n=0; n&lt;instance_number(objObjectParticle); n++)
    {
    i = instance_find(objObjectParticle, n);
    //if (i.moving)
        ds_list_add(instanceList, i);
    }


listSize = ds_list_size(instanceList);
for (n=0; n&lt;listSize; n++)
    {
    instValue = ds_list_find_value(instanceList, n);
    var preCenterX = cellCenterX;
    var preCenterY = cellCenterY;
    cellCenterX = round(instValue.x/64);
    cellCenterY = round(-instValue.y/64);
    
    
    // Do update if the player is in a new cell
    if (cellCenterX != preCenterX)
    || (cellCenterY != preCenterY)
        {
        // Restrict region to inside the map (no point looking for things we know are not there)
        var startX = max(0, cellCenterX-halfRegion);
        var startY = max(0, cellCenterY-halfRegion);
        var endX = min(gridWidth, cellCenterX+halfRegion);
        var endY = min(gridHeight, cellCenterY+halfRegion);
        
        var xx, yy, cellID, existingCell;
        
        for (xx=startX; xx&lt;endX; xx++)
            {
            for (yy=startY; yy&lt;endY; yy++)
                {
                // Get uid for this cell
                cellID = "x"+string(xx)+"y"+string(yy)+"z"+string(0);
                
                // If this cell already has a body attached to it
                existingCell = ds_list_find_index(phyCache, cellID);
                if (existingCell != -1)
                    {
                    // Copy over to active list
                    ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell));
                    ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell+1));
                    ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell+2));
                    
                    // Remove from cache list
                    ds_list_delete(phyCache, existingCell);
                    ds_list_delete(phyCache, existingCell);
                    ds_list_delete(phyCache, existingCell);
                    }
                    
                // There is nothing currently for this cell
                else if (ds_list_find_index(phyActive, cellID) == -1)
                    {
                    // Get type of cell
                    cellValue = GetBlockIndex(xx, yy, 5);
                    
                    // If cell is a building
                    if (cellValue &gt; 1)
                        {
                        // If there's a spare fixture currently unused, use it
                        if (!ds_list_empty(phyFree))
                            {
                            index = max(0, ds_list_find_index(phyFree, cellID));
                            
                            // Get old cellID
                            oldID = ds_list_find_value(phyFree, index);
                            
                            // Get and move the instance
                            inst = ds_list_find_value(phyFree, index+2);
                            inst.phy_position_x = xx*64;
                            inst.phy_position_y = -yy*64;
                            
                            // Get the type (later this could be adapted to swap fixture)
                            type = ds_list_find_value(phyFree, index+1);
                            
                            // Add all the to the active list
                            ds_list_add(phyActive, cellID);
                            ds_list_add(phyActive, type);
                            ds_list_add(phyActive, inst);
                            
                            // Delete the item from the free list
                            ds_list_delete(phyFree, index);
                            ds_list_delete(phyFree, index);
                            ds_list_delete(phyFree, index);
                            }
                            
                        // If there's no spare fixtures left, create one
                        else
                            {
                            inst = instance_create(xx*64, -yy*64, objFixture);
                            physics_fixture_bind(global.physicsBlock, inst);
                            ds_list_add(phyActive, cellID);
                            ds_list_add(phyActive, global.physicsBlock);
                            ds_list_add(phyActive, inst);
                            }
                        }
                    }
                }
            }
        }
    }
    
// Move leftover items from the cache list to free list
for (n=0; n&lt;ds_list_size(phyCache); n+=3)
    {
    ds_list_add(phyFree, ds_list_find_value(phyCache, n));
    ds_list_add(phyFree, ds_list_find_value(phyCache, n+1));
    ds_list_add(phyFree, ds_list_find_value(phyCache, n+2));
    }
    
ds_list_copy(phyCache, phyActive);  // Move active list to cache list
ds_list_clear(phyActive);           // Clear the active list (to refill next time)




/*
// Define the grid area around the player to check for collision spaces
var preCenterX = cellCenterX;
var preCenterY = cellCenterY;
cellCenterX = round(objBody.x/64);
cellCenterY = round(-objBody.y/64);


// Do update if the player is in a new cell
if (cellCenterX != preCenterX)
|| (cellCenterY != preCenterY)
    {
    // Restrict region to inside the map (no point looking for things we know are not there)
    var startX = max(0, cellCenterX-halfRegion);
    var startY = max(0, cellCenterY-halfRegion);
    var endX = min(gridWidth, cellCenterX+halfRegion);
    var endY = min(gridHeight, cellCenterY+halfRegion);
    
    var xx, yy, cellID, existingCell;
    
    for (xx=startX; xx&lt;endX; xx++)
        {
        for (yy=startY; yy&lt;endY; yy++)
            {
            // Get uid for this cell
            cellID = "x"+string(xx)+"y"+string(yy)+"z"+string(0);
            
            // If this cell already has a body attached to it
            existingCell = ds_list_find_index(phyCache, cellID);
            if (existingCell != -1)
                {
                // Copy over to active list
                ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell));
                ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell+1));
                ds_list_add(phyActive, ds_list_find_value(phyCache, existingCell+2));
                
                // Remove from cache list
                ds_list_delete(phyCache, existingCell);
                ds_list_delete(phyCache, existingCell);
                ds_list_delete(phyCache, existingCell);
                }
                
            // There is nothing currently for this cell
            else if (ds_list_find_index(phyActive, cellID) == -1)
                {
                // Get type of cell
                cellValue = GetBlockIndex(xx, yy, 5);
                
                // If cell is a building
                if (cellValue &gt; 1)
                    {
                    // If there's a spare fixture currently unused, use it
                    if (!ds_list_empty(phyFree))
                        {
                        index = max(0, ds_list_find_index(phyFree, cellID));
                        
                        // Get old cellID
                        oldID = ds_list_find_value(phyFree, index);
                        
                        // Get and move the instance
                        inst = ds_list_find_value(phyFree, index+2);
                        inst.phy_position_x = xx*64;
                        inst.phy_position_y = -yy*64;
                        
                        // Get the type (later this could be adapted to swap fixture)
                        type = ds_list_find_value(phyFree, index+1);
                        
                        // Add all the to the active list
                        ds_list_add(phyActive, cellID);
                        ds_list_add(phyActive, type);
                        ds_list_add(phyActive, inst);
                        
                        // Delete the item from the free list
                        ds_list_delete(phyFree, index);
                        ds_list_delete(phyFree, index);
                        ds_list_delete(phyFree, index);
                        }
                        
                    // If there's no spare fixtures left, create one
                    else
                        {
                        inst = instance_create(xx*64, -yy*64, objFixture);
                        physics_fixture_bind(global.physicsBlock, inst);
                        ds_list_add(phyActive, cellID);
                        ds_list_add(phyActive, global.physicsBlock);
                        ds_list_add(phyActive, inst);
                        }
                    }
                }
            }
        }
    
    // Move leftover items from the cache list to free list
    for (n=0; n&lt;ds_list_size(phyCache); n+=3)
        {
        ds_list_add(phyFree, ds_list_find_value(phyCache, n));
        ds_list_add(phyFree, ds_list_find_value(phyCache, n+1));
        ds_list_add(phyFree, ds_list_find_value(phyCache, n+2));
        }
        
    ds_list_copy(phyCache, phyActive);  // Move active list to cache list
    ds_list_clear(phyActive);           // Clear the active list (to refill next time)
    }
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
/// Draw Debug Information
if (global.drawDebug)
    {
    var xPos   = browser_width - 256;
    var yPos   = 0;
    var width  = 256;
    var height = 512;
    
    draw_set_color(c_black);
    draw_set_alpha(0.5);
    draw_rectangle(xPos, yPos, xPos+width, yPos+height, 0);
    
    draw_set_color(c_white);
    draw_set_alpha(1.0);
    
    draw_text(xPos+8, yPos+8, "Cell Position: "+string(cellCenterX)+", "+string(cellCenterY)+": "+string(GetBlockIndex(cellCenterX, cellCenterY, 5)));
    
    draw_text(xPos+8, yPos+16+8, "Free List");
    for (n=0; n&lt;ds_list_size(phyFree)/3; n++)
        {
        draw_text(xPos+8, yPos+40+n*16, ds_list_find_value(phyFree, n*3));
        }
    
    draw_text(xPos+96, yPos+16+8, "Cache List");
    for (n=0; n&lt;ds_list_size(phyCache)/3; n++)
        {
        draw_text(xPos+96, yPos+40+n*16, ds_list_find_value(phyCache, n*3));
        }
    }
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
