<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10010</depth>
  <persistent>0</persistent>
  <parentName>oHUDParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited()

//What is drawn top left of window
WindowCaption="TILE SELECT";

//Tab details
TabMax=3
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*display_set_gui_size(window_get_width(),window_get_height())*/

draw_set_color(c_black)
draw_set_alpha(0.8)
draw_rectangle(x,y,x+WindowWidth,y+WindowHeight,0)
draw_set_alpha(1)

//Draw top rectangle and outline of window
draw_set_color($EEEEEE)
draw_rectangle(x,y,x+WindowWidth,y+38,0)
draw_set_alpha(0.5);
draw_rectangle(x,y+39,x+WindowWidth,y+72,0)
draw_set_alpha(1);
draw_line(x,y+39,x+WindowWidth,y+39)
draw_line(x,y+72,x+WindowWidth,y+72)

//Draw the window's caption
draw_set_color(c_black)
draw_set_font(fTwCenM)
draw_set_halign(fa_center)
draw_set_valign(fa_center)
draw_text(x+(WindowWidth/2),y+19,WindowCaption)

//Draw the tabs
draw_set_halign(fa_center)
draw_set_font(fTwCenConM)
for( var i=0; i&lt;=TabMax; i+=1)
{
    var tabx1=x+(i*86); //X location of this tab
    
    //Logic for selecting tabs
    if (mouse_click_rectangle(tabx1,y+39,tabx1+86,y+72) &amp;&amp; !instance_exists(oHeadMenu))
    {
        Tab=i;
        if (Tab==0) global.EditorMode_Sub=EDIT_SUB_SIDE;
        else if (Tab!=4) global.EditorMode_Sub=EDIT_SUB_LID;
        WindowContentRedraw=true;
    }
    
    //Selected colour
    if (i==Tab)
    {
        draw_set_color($EEEEEE);
        draw_set_alpha(0.5);
        draw_rectangle(tabx1,y+39,tabx1+86,y+72,0);
        draw_set_alpha(1);
    }
    
    //Outline
    draw_set_color(c_white);
    //draw_rectangle(tabx1,y+41,tabx1+82,y+67,1);
    draw_line(tabx1+85,y+39,tabx1+86,y+72);   
    
    //Text
    var      str="WALLS";
    if(i==1) str="ROOFS";
    if(i==2) str="ROADS";
    if(i==3) str="LANDSCAPE";
    if(i==4) str="FIRST TOP";
    if (i==Tab) draw_set_color(c_black);
    draw_text(tabx1+43,y+56,str); 
}

//Draw the right hand bar
draw_set_color(c_white)
draw_line(x+WindowWidth-25,y+72,x+WindowWidth-25,y+WindowHeight)
draw_set_alpha(0.3)
draw_rectangle(x+WindowWidth-25,y+72,x+WindowWidth,y+WindowHeight,0)
draw_set_alpha(1)

draw_rectangle(x+WindowWidth-25,y+72,x+WindowWidth,y+97,1) //Scrollbar up
draw_sprite(sHUDScrollArrow,0,x+WindowWidth-12,y+85)
draw_rectangle(x+WindowWidth-25,y+WindowHeight-50,x+WindowWidth,y+WindowHeight-25,1) //Scrollbar down
draw_sprite(sHUDScrollArrow,1,x+WindowWidth-12,y+WindowHeight-37)

draw_rectangle(x+WindowWidth-25,y+WindowHeight-25,x+WindowWidth,y+WindowHeight,1) //Resize window

//Control &amp; draw scrolling
if (WindowContentYMin!=0) //Can scroll
{
    //Temporary variables
    var scrolly=0;
    var scrollymin=0;
    var scrollymax=WindowHeight-56-32-101;
    var scrollchanged=0;
    
    scrolly=lerp(scrollymin,scrollymax,abs(WindowContentY/WindowContentYMin))
    
    if (Holding==3)
    {
        scrolly=clamp(device_mouse_raw_y(0)-(y+101)-16,scrollymin,scrollymax)
        scrollchanged=1;
    }
    
    draw_rectangle(x+WindowWidth-25,y+scrolly+98,x+WindowWidth,y+scrolly+98+41,0)
    
    //If you press the "Up" scroll button or mouse wheel up
    if (mouse_click_rectangle(x+WindowWidth-25,y+72,x+WindowWidth,y+97)
        or (mouse_wheel_up() &amp;&amp; mouse_rectangle(x,y+73,x+WindowWidth-28,y+WindowHeight))) &amp;&amp; !instance_exists(oHeadMenu)
    {
        scrolly=clamp(scrolly-20,scrollymin,scrollymax)
        scrollchanged=1;
        
        if (mouse_wheel_up()) {with(oHUDMain) DisableWheel=true}
    }
    //If you press the "Down" scroll button
    if (mouse_click_rectangle(x+WindowWidth-25,y+WindowHeight-50,x+WindowWidth,y+WindowHeight-25)
        or (mouse_wheel_down() &amp;&amp; mouse_rectangle(x,y+73,x+WindowWidth-28,y+WindowHeight))) &amp;&amp; !instance_exists(oHeadMenu)
    {
        scrolly=clamp(scrolly+20,scrollymin,scrollymax)
        scrollchanged=1;
        
        if (mouse_wheel_down()) {with(oHUDMain) DisableWheel=true}
    }
    
    if (scrollchanged==1)
    {
        WindowContentY=-lerp(0,WindowContentYMin,abs(scrolly/scrollymax))
        WindowContentRedraw=true;
    }    
}

//Control &amp; draw window content
draw_set_color(c_white)

//If you click the surface, remember the click position to process tile selection
if (mouse_click_rectangle(x,y+73,x+WindowWidth-28,y+WindowHeight)) &amp;&amp; !instance_exists(oHeadMenu)
{
    WindowContentClicked=1;
    WindowContentRedraw=true;
    WindowContentClickedX=device_mouse_raw_x(0)-(x);
    WindowContentClickedY=device_mouse_raw_y(0)-(y+73)+(WindowContentY);
}
if (mouse_rclick_rectangle(x,y+73,x+WindowWidth-28,y+WindowHeight)) &amp;&amp; !instance_exists(oHeadMenu)
{
    WindowContentClicked=2;
    WindowContentRedraw=true;
    WindowContentClickedX=device_mouse_raw_x(0)-(x);
    WindowContentClickedY=device_mouse_raw_y(0)-(y+73)+(WindowContentY);
}
draw_surface_part(WindowContent,0,WindowContentY,WindowWidth-25,WindowHeight-73,x,y+WindowContentDrawY)

draw_set_color(c_white)
draw_rectangle(x,y,x+WindowWidth,y+WindowHeight,1)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw window content

//Redraw the surface if it doesn't exist
if (!surface_exists(WindowContent))
{
    WindowContentRedraw=true;
    WindowContent=surface_create(1024,1024);
}

//If the surface is flagged to redraw, do it now
if (WindowContentRedraw==true
&amp;&amp; instance_exists(oMap) &amp;&amp; !instance_exists(oHeadMenu))
{
    d3d_end();
    d3d_transform_set_identity();
    surface_set_target(WindowContent);
    draw_clear_alpha(c_white,0.3);
    
    var iteration=0, iterationMax=0;
    
    //Read the group/entity details from the supplied .ini file
    ini_open("style1.yyg")
    var i=Tab;
    {
        //Set the correct section and key we're reading from
        var        itemSection="tiles"    ,itemKey="sides";
        if (i==1) {itemSection="tiles"    ;itemKey="tops";}
        if (i==2) {itemSection="roads"    ;itemKey="roads";}
        if (i==3) {itemSection="landscape";itemKey="ls";}
        if (i==4) {itemSection="tiles"    ;itemKey="sides";}
        
        itemMax[0]=ini_read_real("details","tilesGroupCount",0)
        itemMax[1]=ini_read_real("details","tilesGroupCount",0)
        itemMax[2]=ini_read_real("details","roadsGroupCount",0)
        itemMax[3]=ini_read_real("details","landscapeGroupCount",0)
        itemMax[4]=ini_read_real("details","tilesGroupCount",0)
        
        show_debug_message("Tiles: "+string(itemMax[0]))
        
        //For each "group" as defined in the ini file
        for(var j=0; j&lt;itemMax[i]; j+=1)
        {
            //Set name, description (currently not used) and temporary string of appropriate tiles
            var itemName; itemName[i,j]=ini_read_string(itemSection,"name"+string(j),"MISSINGNO");
            var itemDesc; itemDesc[i,j]=ini_read_string(itemSection,"desc"+string(j),"MISSINGNO");
            var itemListPred           =ini_read_string(itemSection,itemKey+"_list"+string(j),"");
            
            //Turn the string of tiles "0,1,4,7,12,13,14" into
            //a queue of those numbers as real values
            var itemList; itemList[i,j]=ds_queue_create();
            while (string_length(itemListPred)&gt;0)
            {
                if (string_pos(",",itemListPred))
                {
                    var pos=string_pos(",",itemListPred);
                    ds_queue_enqueue(itemList[i,j],real(string_copy(itemListPred,1,pos-1)))
                    itemListPred=string_copy(itemListPred,pos+1,string_length(itemListPred)-(pos))
                }
                else
                {
                    ds_queue_enqueue(itemList[i,j],real(itemListPred))
                    itemListPred=""
                }        
            }
        }
    }
    ini_close()
    
    //Set tileset
    var tilesprite=sStyle1, spritewidth=sprite_get_width(tilesprite);
    //Set tile sizes
    var tileW=70, tileH=70, tileActW=64, tileActH=64, tileDiffX=(tileW-tileActW)/2, tileDiffY=(tileH-tileActH)/2;
    //Set tile count and current location/number
    var maxsprite=38, cursprite=0, curX=0, curY=0;
    //Set drawing positions and constraints
    var drawX=0, drawY=-9, drawXoff=32, drawYoff=32, drawXmax=(WindowWidth-28-(drawXoff*2)), drawGap=16;
    
    //Loop through each of the groups, drawing its name, tiles etc
    for(var i=0; i&lt;itemMax[Tab]; i+=1)
    {
        if !ds_queue_empty(itemList[Tab,i]) //If there's nothing in the section, skip it altogether
        {
            //Start by drawing the group's name
            draw_set_color(c_white)
            draw_line(0,drawY+(drawYoff*0.25),2048,drawY+(drawYoff*0.25))
            draw_set_alpha(0.7)
            draw_rectangle(0,drawY+(drawYoff*0.25),2048,drawY+(drawYoff*1.75),0)
            draw_set_alpha(1)
            
            draw_set_color(c_black);
            draw_set_font(fTwCenM);
            draw_set_halign(fa_left);
            draw_set_valign(fa_center);
            draw_text(drawXoff,drawY+drawYoff,string_upper(itemName[Tab,i]));
            
            drawY+=40
        
            //Go through the queue of tiles in this group, drawing and controlling each one
            while !ds_queue_empty(itemList[Tab,i])
            {
                cursprite=ds_queue_dequeue(itemList[Tab,i])
                if (Tab!=0 &amp;&amp; Tab!=4) cursprite+=oMap.TopBase
                
                curX=0; curY=0;
                
                //Find the coordinates of the current tile on the tile sheet
                repeat(cursprite)
                {
                    curX+=tileW;
                    if (curX+tileW&gt;spritewidth)
                    {
                        curX=0;
                        curY+=tileH;
                    }
                }
                
                //If you clicked the current tile (1=left, 2=right), select it
                if (WindowContentClicked&gt;0)
                {
                    if (WindowContentClickedX&gt;drawX+drawXoff
                    &amp;&amp;  WindowContentClickedY&gt;drawY+drawYoff
                    &amp;&amp;  WindowContentClickedX&lt;drawX+drawXoff+tileActW
                    &amp;&amp;  WindowContentClickedY&lt;drawY+drawYoff+tileActH) //If you clicked on this tile to select it
                    {
                        if (WindowContentClicked==1)
                        {
                            WindowContentSelectedL[Tab]=cursprite;
                            global.LeftMouseTile=cursprite;
                            
                        }
                        if (WindowContentClicked==2)
                        {
                            WindowContentSelectedR[Tab]=cursprite
                            global.RightMouseTile=cursprite;
                        }
                        
                        Holding=4;
                            
                        if (cursprite&gt;=oMap.TopBase)
                        {
                            if (WindowContentClicked==1) global.LeftMouseTile-=oMap.TopBase;
                            if (WindowContentClicked==2) global.RightMouseTile-=oMap.TopBase;
                            SetHoldingQuickSlot(EDIT_PAINT,EDIT_SUB_LID,cursprite-oMap.TopBase,tilesprite,curX+tileDiffX,curY+tileDiffY,tileActW,tileActH)
                            global.EditorMode_Sub=EDIT_SUB_LID;    
                        }
                        else
                        {
                            SetHoldingQuickSlot(EDIT_PAINT,EDIT_SUB_SIDE,cursprite,tilesprite,curX+tileDiffX,curY+tileDiffY,tileActW,tileActH)
                            global.EditorMode_Sub=EDIT_SUB_SIDE;
                        }   
                    }
                }
                
                //Draw tile drop shadow
                draw_sprite(sHUDTileShadow,0,drawX+drawXoff,drawY+drawYoff);
                
                //Draw the relevant section of the spritesheet
                draw_sprite_part(tilesprite,0,
                                 curX+tileDiffX,curY+tileDiffY,
                                 tileActW,tileActH,
                                 drawX+drawXoff,drawY+drawYoff);
                
                //Draw a border around this tile if it's the selected one
                if (WindowContentSelectedL[Tab]==cursprite)
                {
                    draw_sprite(sHUDTileHighlight,0,drawX+drawXoff,drawY+drawYoff)
                    
                    if (keyboard_check(ord("X")))
                    {
                        SetQuickSlot(EDIT_PAINT,global.EditorMode_Sub,cursprite,tilesprite,curX+tileDiffX,curY+tileDiffY,tileActW,tileActH)    
                    }
                    
                    if (instance_exists(oHUDMain))
                    {
                        oHUDMain.QuickSlot[oHUDMain.QuickSlotSelected,0]=EDIT_PAINT;
                    }
                }
                if (WindowContentSelectedR[Tab]==cursprite)
                {
                    draw_sprite(sHUDTileHighlight,1,drawX+drawXoff,drawY+drawYoff)
                }
                                 
                //Move boundaries as necessary
                if !ds_queue_empty(itemList[Tab,i])
                {
                    drawX+=tileW+drawGap;
                    if (drawX+tileW&gt;drawXmax+drawXoff)
                    {
                        drawX=0;
                        drawY+=tileH+drawGap;
                    }
                }
            }
            
            drawX=0;
            
            if(i&lt;itemMax[Tab]-1)
            {
                drawY+=tileH+drawGap+20;
            }
        }
    }
    
    WindowContentHeight=drawY+tileH+(drawYoff*2)
    
    //Bring back the 3D, we're done drawing now
    draw_set_color(c_white);
    surface_reset_target();
    d3d_start();

    WindowContentYMin=min(0,(WindowHeight-WindowContentDrawY)-WindowContentHeight);
    if (WindowContentClicked&gt;0)
    {
        WindowContentClicked=0;
        WindowContentRedraw=true;
    }
    else
    {
        WindowContentRedraw=false;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
